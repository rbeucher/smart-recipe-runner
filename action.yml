name: 'Smart Recipe Runner'
description: 'Generate PBS scripts for ESMValTool and COSIMA recipes with intelligent resource allocation'
author: 'ESMValTool Community'

inputs:
  recipe_type:
    description: 'Type of recipe: esmvaltool or cosima'
    required: true
  recipe_name:
    description: 'Name of the recipe to run'
    required: true
  config:
    description: 'Recipe configuration (JSON string)'
    required: false
    default: '{}'
  esmvaltool_version:
    description: 'ESMValTool version to use (for esmvaltool recipes)'
    required: false
    default: 'main'
  conda_module:
    description: 'Conda module to load'
    required: false
    default: 'conda/analysis3'
  repository_url:
    description: 'Custom repository URL for cloning'
    required: false

outputs:
  status:
    description: 'Generation status (pbs-generated or error)'
    value: ${{ steps.generate-pbs.outputs.status }}
  pbs_filename:
    description: 'Generated PBS script filename'
    value: ${{ steps.generate-pbs.outputs.pbs_filename }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python Environment
      shell: bash
      run: |
        python -m pip install --upgrade pip
        python -m pip install pyyaml
        
    - name: Setup Smart Recipe Runner
      shell: bash
      run: |
        export PYTHONPATH="${PYTHONPATH}:${{ github.action_path }}/lib"
        echo "PYTHONPATH=${PYTHONPATH}" >> $GITHUB_ENV
        
    - name: Validate Inputs
      shell: bash
      run: |
        # Validate recipe type
        recipe_type="${{ inputs.recipe_type }}"
        if [[ "$recipe_type" != "esmvaltool" && "$recipe_type" != "cosima" ]]; then
          echo "âŒ Invalid recipe_type: $recipe_type. Must be 'esmvaltool' or 'cosima'"
          exit 1
        fi
        
        # Validate recipe name
        if [[ -z "${{ inputs.recipe_name }}" ]]; then
          echo "âŒ recipe_name is required"
          exit 1
        fi
        
        echo "âœ… Input validation passed"
        echo "Recipe type: $recipe_type"
        echo "Recipe name: ${{ inputs.recipe_name }}"
        
    - name: Generate PBS Script
      id: generate-pbs
      shell: bash
      run: |
        echo "ğŸ¯ Generating PBS script for ${{ inputs.recipe_type }} recipe: ${{ inputs.recipe_name }}"
        
        # Create simple PBS generation script
        cat > generate_pbs.py << 'EOF'
        import sys
        import os
        import json
        from pathlib import Path
        
        # Add lib directory to path
        sys.path.insert(0, os.path.join(os.environ.get('GITHUB_ACTION_PATH', '.'), 'lib'))
        
        try:
            from recipe_runner import SmartRecipeRunner
            
            # Create runner
            runner = SmartRecipeRunner()
            
            # Get parameters
            recipe_name = sys.argv[1]
            config_json = sys.argv[2] if len(sys.argv) > 2 else '{}'
            recipe_type = sys.argv[3] if len(sys.argv) > 3 else 'esmvaltool'
            esmvaltool_version = sys.argv[4] if len(sys.argv) > 4 else 'main'
            conda_module = sys.argv[5] if len(sys.argv) > 5 else 'conda/access-med'
            repository_url = sys.argv[6] if len(sys.argv) > 6 and sys.argv[6] != 'None' else None
            
            print(f"Parameters:")
            print(f"  Recipe: {recipe_name}")
            print(f"  Type: {recipe_type}")
            print(f"  Config: {config_json}")
            print(f"  ESMValTool version: {esmvaltool_version}")
            print(f"  Conda module: {conda_module}")
            print(f"  Repository URL: {repository_url}")
            
            # Generate PBS script
            result = runner.run(
                recipe_name=recipe_name,
                config_json=config_json,
                recipe_type=recipe_type,
                esmvaltool_version=esmvaltool_version,
                conda_module=conda_module,
                repository_url=repository_url
            )
            
            print(f"âœ… PBS generation completed: {result}")
            
            # Write outputs for GitHub Actions
            with open('pbs_result.txt', 'w') as f:
                f.write(f"status={result[0]}\n")
                f.write(f"pbs_filename={result[1]}\n")
                
        except Exception as e:
            print(f"âŒ Error generating PBS script: {e}")
            import traceback
            traceback.print_exc()
            
            with open('pbs_result.txt', 'w') as f:
                f.write("status=error\n")
                f.write("pbs_filename=\n")
            sys.exit(1)
        EOF
        
        # Run PBS generation
        python generate_pbs.py \
          "${{ inputs.recipe_name }}" \
          "${{ inputs.config }}" \
          "${{ inputs.recipe_type }}" \
          "${{ inputs.esmvaltool_version }}" \
          "${{ inputs.conda_module }}" \
          "${{ inputs.repository_url }}"
        
        # Set outputs
        if [[ -f "pbs_result.txt" ]]; then
          while IFS= read -r line; do
            echo "$line" >> $GITHUB_OUTPUT
          done < pbs_result.txt
        else
          echo "status=error" >> $GITHUB_OUTPUT
          echo "pbs_filename=" >> $GITHUB_OUTPUT
        fi
        
    - name: Display Results
      shell: bash
      run: |
        echo "ğŸ“‹ PBS Script Generation Results:"
        echo "Status: ${{ steps.generate-pbs.outputs.status }}"
        echo "PBS Filename: ${{ steps.generate-pbs.outputs.pbs_filename }}"
        
        if [[ "${{ steps.generate-pbs.outputs.status }}" == "pbs-generated" ]]; then
          echo ""
          echo "âœ… PBS script generated successfully!"
          echo "ğŸ“ Script saved as: ${{ steps.generate-pbs.outputs.pbs_filename }}"
          
          if [[ -f "${{ steps.generate-pbs.outputs.pbs_filename }}" ]]; then
            echo ""
            echo "--- PBS Script Content Preview ---"
            head -20 "${{ steps.generate-pbs.outputs.pbs_filename }}"
            echo "..."
            echo "--- End Preview ---"
          fi
        else
          echo "âŒ PBS script generation failed"
          exit 1
        fi

branding:
  icon: 'play-circle'
  color: 'blue'
