name: 'Smart Recipe Runner'
description: 'Test ESMValTool recipes and Jupyter notebooks with intelligent resource allocation'
author: 'ESMValTool Community'

inputs:
  # Mode selection
  mode:
    description: 'Execution mode: recipe, notebook, or both'
    required: false
    default: 'recipe'
  
  # Recipe-specific inputs
  recipe:
    description: 'Name of the ESMValTool recipe to run (alias for recipe_name)'
    required: false
  recipe_name:
    description: 'Name of the ESMValTool recipe to run'
    required: false
  esmvaltool_repository:
    description: 'ESMValTool repository URL'
    required: false
    default: 'https://github.com/ESMValGroup/ESMValTool'
  esmvaltool_branch:
    description: 'ESMValTool repository branch'
    required: false
    default: 'main'
  config:
    description: 'Recipe configuration (JSON string or file path)'
    required: false
  esmvaltool_version:
    description: 'ESMValTool version to use'
    required: false
    default: 'main'
  conda_module:
    description: 'Conda module name for ESMValTool'
    required: false
    default: 'esmvaltool'
  
  # Notebook-specific inputs
  repository_url:
    description: 'URL of the repository containing notebooks to test'
    required: false
  notebook_categories:
    description: 'Notebook categories to test (comma-separated: appetisers,mains,tutorials,desserts,papers,all)'
    required: false
    default: 'appetisers,tutorials'
  notebook_mode:
    description: 'Notebook test mode: test, validate, or dry-run'
    required: false
    default: 'test'
  max_parallel:
    description: 'Maximum parallel notebook executions'
    required: false
    default: '3'
  continue_on_error:
    description: 'Continue testing even if notebooks fail'
    required: false
    default: 'true'
    
  # General inputs
  dry_run:
    description: 'Perform dry run without actual execution'
    required: false
    default: 'false'
  timeout:
    description: 'Maximum execution time in seconds'
    required: false
    default: '3600'

outputs:
  status:
    description: 'Execution status'
    value: ${{ steps.Set\ Outputs.outputs.status }}
  job_id:
    description: 'PBS job ID (if applicable)'
    value: ${{ steps.Set\ Outputs.outputs.job_id }}
  resource_group:
    description: 'Resource group used for execution'
    value: ${{ steps.Set\ Outputs.outputs.resource_group }}
  report_path:
    description: 'Path to generated test report'
    value: ${{ steps.Set\ Outputs.outputs.report_path }}
  summary:
    description: 'Execution summary'
    value: ${{ steps.Set\ Outputs.outputs.summary }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python Environment
      shell: bash
      run: |
        python -m pip install --upgrade pip
        python -m pip install pyyaml dataclasses-json pytest pytest-cov nbformat nbconvert
        
    - name: Setup Smart Recipe Runner
      shell: bash
      run: |
        export PYTHONPATH="${PYTHONPATH}:${{ github.action_path }}/lib"
        echo "PYTHONPATH=${PYTHONPATH}" >> $GITHUB_ENV
        echo "Action path: ${{ github.action_path }}"
        
    - name: Validate Inputs
      shell: bash
      run: |
        mode="${{ inputs.mode }}"
        if [[ "$mode" == "recipe" ]]; then
          if [[ -z "${{ inputs.recipe_name }}" ]]; then
            echo "âŒ recipe_name is required when mode=recipe"
            exit 1
          fi
        elif [[ "$mode" == "notebook" ]]; then
          if [[ -z "${{ inputs.repository_url }}" ]]; then
            echo "âŒ repository_url is required when mode=notebook"
            exit 1
          fi
        elif [[ "$mode" == "both" ]]; then
          if [[ -z "${{ inputs.recipe_name }}" || -z "${{ inputs.repository_url }}" ]]; then
            echo "âŒ Both recipe_name and repository_url are required when mode=both"
            exit 1
          fi
        else
          echo "âŒ Invalid mode: $mode. Must be 'recipe', 'notebook', or 'both'"
          exit 1
        fi
        
    - name: Clone ESMValTool Repository
      if: inputs.mode == 'recipe' || inputs.mode == 'both'
      shell: bash
      run: |
        echo "ðŸ”„ Cloning ESMValTool repository..."
        git clone --depth 1 --branch "${{ inputs.esmvaltool_branch }}" "${{ inputs.esmvaltool_repository }}" ./esmvaltool-repo
        echo "ðŸ“ ESMValTool repository cloned to ./esmvaltool-repo"
        echo "ðŸ” Available recipes:"
        find ./esmvaltool-repo/esmvaltool/recipes -name "*.yml" | head -10
        echo "   ... (showing first 10 recipes)"
        total_recipes=$(find ./esmvaltool-repo/esmvaltool/recipes -name "*.yml" | wc -l)
        echo "ðŸ“Š Total recipes found: $total_recipes"
        
    - name: Clone Notebook Repository
      if: inputs.mode == 'notebook' || inputs.mode == 'both'
      shell: bash
      run: |
        if [[ -n "${{ inputs.repository_url }}" ]]; then
          echo "ðŸ”„ Cloning notebook repository..."
          git clone "${{ inputs.repository_url }}" ./notebook-repo
          echo "ðŸ“ Repository cloned to ./notebook-repo"
          ls -la ./notebook-repo
        fi
        
    - name: Discover and Analyze Notebooks
      if: inputs.mode == 'notebook' || inputs.mode == 'both'
      shell: bash
      run: |
        echo "ðŸ” Discovering notebooks..."
        python ${{ github.action_path }}/lib/notebook-manager.py analyze \
          --repo-path ./notebook-repo \
          --categories "${{ inputs.notebook_categories }}" \
          --output notebook-matrix.json
        
        echo "ðŸ“Š Notebook analysis complete:"
        cat > analyze_report.py << 'EOF'
        import json
        with open('notebook-matrix.json', 'r') as f:
            matrix = json.load(f)
        print(f'Repository type: {matrix["repository_type"]}')
        print(f'Total notebooks: {matrix["total_notebooks"]}')
        for cat, data in matrix['categories'].items():
            if data['count'] > 0:
                print(f'  {cat}: {data["count"]} notebooks')
        EOF
        python analyze_report.py
        
    - name: Test Notebooks
      if: inputs.mode == 'notebook' || inputs.mode == 'both'
      shell: bash
      run: |
        echo "ðŸ§ª Testing notebooks..."
        python ${{ github.action_path }}/lib/notebook-runner.py run \
          --matrix notebook-matrix.json \
          --mode "${{ inputs.notebook_mode }}" \
          --max-parallel "${{ inputs.max_parallel }}" \
          $([ "${{ inputs.continue_on_error }}" == "true" ] && echo "--continue-on-error") \
          --output notebook-test-report.json
          
    - name: Run ESMValTool Recipe
      if: inputs.mode == 'recipe' || inputs.mode == 'both'
      shell: bash
      run: |
        echo "ðŸ§ª Running ESMValTool recipe..."
        
        # Determine execution mode
        if [[ "${{ inputs.dry_run }}" == "true" ]]; then
          mode="dry-run"
        else
          mode="run"
        fi
        
        # Create recipe runner script
        cat > run_recipe.py << 'EOF'
        import sys
        import os
        import json
        from pathlib import Path
        sys.path.insert(0, os.environ.get('PYTHONPATH', '').split(':')[1])
        
        from recipe_runner import SmartRecipeRunner
        
        # Determine recipe directory - look for cloned ESMValTool repo
        recipe_dir = None
        potential_paths = [
            './esmvaltool-repo/esmvaltool/recipes',
            '../esmvaltool-repo/esmvaltool/recipes',
            'esmvaltool-repo/esmvaltool/recipes'
        ]
        for path in potential_paths:
            if Path(path).exists():
                recipe_dir = path
                print(f"ðŸ“ Found ESMValTool recipes at: {recipe_dir}")
                break
        
        runner = SmartRecipeRunner(
            hpc_system='local',
            log_dir='./logs',
            recipe_dir=recipe_dir
        )
        
        try:
            result = runner.run(
                recipe_name=sys.argv[1],
                config_json=sys.argv[2] if sys.argv[2] else '{}',
                esmvaltool_version=sys.argv[3],
                conda_module=sys.argv[4],
                mode=sys.argv[5]
            )
            
            print(f'Recipe execution result: {result}')
            
            # Save results for output
            with open('recipe-result.json', 'w') as f:
                json.dump({
                    'status': result[0] if result else 'unknown',
                    'job_id': result[1] if len(result) > 1 else None,
                    'mode': sys.argv[5]
                }, f)
                
        except Exception as e:
            print(f'Error running recipe: {e}')
            with open('recipe-result.json', 'w') as f:
                json.dump({
                    'status': 'error',
                    'error': str(e),
                    'mode': sys.argv[5]
                }, f)
            sys.exit(1)
        EOF
        
        python run_recipe.py \
          "${{ inputs.recipe_name }}" \
          "${{ inputs.config }}" \
          "${{ inputs.esmvaltool_version }}" \
          "${{ inputs.conda_module }}" \
          "$mode"
        
    - name: Generate Combined Report
      shell: bash
      run: |
        echo "ðŸ“‹ Generating execution report..."
        
        cat > generate_report.py << 'EOF'
        import json
        import os
        from datetime import datetime
        
        # Initialize combined report
        report = {
            'timestamp': datetime.now().isoformat(),
            'mode': os.environ.get('MODE', 'unknown'),
            'summary': {}
        }
        
        # Add notebook results if available
        if os.path.exists('notebook-test-report.json'):
            with open('notebook-test-report.json', 'r') as f:
                notebook_report = json.load(f)
            report['notebook_results'] = notebook_report
            report['summary']['notebooks'] = {
                'total': notebook_report['total_notebooks'],
                'successful': notebook_report['successful'],
                'failed': notebook_report['failed']
            }
        
        # Add recipe results if available  
        if os.path.exists('recipe-result.json'):
            with open('recipe-result.json', 'r') as f:
                recipe_result = json.load(f)
            report['recipe_results'] = recipe_result
            report['summary']['recipe'] = {
                'status': recipe_result['status'],
                'job_id': recipe_result.get('job_id')
            }
        
        # Write combined report
        with open('smart-runner-report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        # Print summary
        print('ðŸŽ¯ Smart Recipe Runner Summary:')
        if 'notebooks' in report['summary']:
            nb_sum = report['summary']['notebooks']
            print(f'   Notebooks: {nb_sum["successful"]}/{nb_sum["total"]} successful')
        if 'recipe' in report['summary']:
            rec_sum = report['summary']['recipe']
            print(f'   Recipe: {rec_sum["status"]}')
            if rec_sum.get('job_id'):
                print(f'   Job ID: {rec_sum["job_id"]}')
        
        print(f'   Full report: smart-runner-report.json')
        EOF
        
        MODE="${{ inputs.mode }}" python generate_report.py
        
    - name: Set Outputs
      shell: bash
      run: |
        # Read the combined report to set outputs
        if [[ -f "smart-runner-report.json" ]]; then
          # Create status extraction script
          cat > extract_status.py << 'EOF'
          import json
          with open('smart-runner-report.json', 'r') as f:
              report = json.load(f)
              
          # Determine overall status
          overall_status = 'success'
          if 'notebook_results' in report:
              if report['notebook_results']['failed'] > 0:
                  overall_status = 'partial_failure'
          if 'recipe_results' in report:
              if report['recipe_results']['status'] in ['error', 'failed']:
                  overall_status = 'failure'
                  
          print(overall_status)
          EOF
          
          status=$(python extract_status.py)
          
          # Create job ID extraction script
          cat > extract_job_id.py << 'EOF'
          import json
          try:
              with open('smart-runner-report.json', 'r') as f:
                  report = json.load(f)
              job_id = report.get('recipe_results', {}).get('job_id', '')
              print(job_id if job_id else '')
          except:
              print('')
          EOF
          
          job_id=$(python extract_job_id.py)
          
          # Create resource group extraction script
          cat > extract_resource_group.py << 'EOF'
          import json
          try:
              with open('smart-runner-report.json', 'r') as f:
                  report = json.load(f)
              resource_group = report.get('recipe_results', {}).get('resource_group', 'unknown')
              print(resource_group if resource_group else 'unknown')
          except:
              print('unknown')
          EOF
          
          resource_group=$(python extract_resource_group.py)
          
          # Set GitHub outputs
          echo "status=$status" >> $GITHUB_OUTPUT
          echo "job_id=$job_id" >> $GITHUB_OUTPUT
          echo "resource_group=$resource_group" >> $GITHUB_OUTPUT
          echo "report_path=smart-runner-report.json" >> $GITHUB_OUTPUT
          
          # Create summary extraction script
          cat > extract_summary.py << 'EOF'
          import json
          with open('smart-runner-report.json', 'r') as f:
              report = json.load(f)
              
          summary_parts = []
          if 'notebook_results' in report:
              nb = report['notebook_results']
              summary_parts.append(f'Notebooks: {nb["successful"]}/{nb["total"]} passed')
          if 'recipe_results' in report:
              rec = report['recipe_results']
              summary_parts.append(f'Recipe: {rec["status"]}')
              
          print('; '.join(summary_parts))
          EOF
          
          summary=$(python extract_summary.py)
          
          echo "summary=$summary" >> $GITHUB_OUTPUT
          
          echo "âœ… Outputs set:"
          echo "  Status: $status"
          echo "  Job ID: $job_id"
          echo "  Resource Group: $resource_group"
          echo "  Summary: $summary"
        else
          echo "status=error" >> $GITHUB_OUTPUT
          echo "summary=No report generated" >> $GITHUB_OUTPUT
        fi

branding:
  icon: 'play-circle'
  color: 'blue'
