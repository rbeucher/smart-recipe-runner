name: 'Smart Recipe Runner'
description: 'Run ESMValTool and COSIMA recipes with matrix generation and PBS job submission. Supports both matrix generation and individual recipe execution.'
author: 'ESMValTool Community'

inputs:
  # Matrix generation inputs
  config_file:
    description: 'Path to YAML configuration file for multi-recipe execution'
    required: false
  
  # Common parameters
  esmvaltool_version:
    description: 'ESMValTool version to use (for esmvaltool recipes)'
    required: false
    default: 'main'
  conda_module:
    description: 'Conda module to load'
    required: false
    default: 'conda/analysis3'
  project:
    description: 'PBS project code (e.g., w40, kj13, etc.)'
    required: false
    default: 'w40'
  repository_url:
    description: 'Repository URL for cloning'
    required: false
  
  # Job submission parameters
  gadi_username:
    description: 'Gadi username for SSH connection'
    required: false
  gadi_ssh_key:
    description: 'SSH private key for Gadi connection'
    required: false
  gadi_ssh_passphrase:
    description: 'Passphrase for SSH private key (if password-protected)'
    required: false
  submit_job:
    description: 'Whether to submit the job to Gadi (true/false)'
    required: false
    default: 'true'
  scripts_dir:
    description: 'Directory on Gadi to upload scripts'
    required: false
    default: '/scratch/$PROJECT/$USER/med-ci'

outputs:
  matrix:
    description: 'Recipe matrix for GitHub Actions (JSON)'
    value: ${{ steps.list-recipes.outputs.matrix }}
  recipe_count:
    description: 'Number of recipes found'
    value: ${{ steps.list-recipes.outputs.recipe_count }}
  status:
    description: 'Execution status (matrix-generated, pbs-generated, job-submitted, or error)'
    value: ${{ steps.set-job-outputs.outputs.status || steps.generate-pbs.outputs.status || steps.list-recipes.outputs.status }}
  pbs_filename:
    description: 'Generated PBS script filename (for single recipe execution)'
    value: ${{ steps.generate-pbs.outputs.pbs_filename }}
  job_id:
    description: 'PBS job ID (if submitted)'
    value: ${{ steps.set-job-outputs.outputs.job_id }}
  gadi_path:
    description: 'Path to script on Gadi (if submitted)'
    value: ${{ steps.set-job-outputs.outputs.gadi_path }}

runs:
  using: 'composite'
  steps:
    - name: Setup Python Environment
      shell: bash
      run: |
        python -m pip install --upgrade pip
        python -m pip install pyyaml
        
    - name: Setup Smart Recipe Runner
      shell: bash
      run: |
        export PYTHONPATH="${PYTHONPATH}:${{ github.action_path }}/lib"
        echo "PYTHONPATH=${PYTHONPATH}" >> $GITHUB_ENV
        
    - name: Determine Execution Mode
      id: mode
      shell: bash
      run: |
        # If we have config_file, generate matrix
        # Otherwise, execute single recipe (recipe_name will come from matrix)
        if [[ -n "${{ inputs.config_file }}" ]]; then
          echo "mode=matrix" >> $GITHUB_OUTPUT
          echo "ğŸ“‹ Matrix generation mode"
        else
          echo "mode=single" >> $GITHUB_OUTPUT
          echo "ğŸ¯ Single recipe execution mode"
        fi
        
    - name: Validate Matrix Inputs
      if: steps.mode.outputs.mode == 'matrix'
      shell: bash
      run: |
        # Validate that config_file exists
        config_file="${{ inputs.config_file }}"
        
        if [[ ! -f "$config_file" ]]; then
          echo "âŒ Configuration file not found: $config_file"
          exit 1
        fi
        
        echo "âœ… Matrix input validation passed"
        echo "Using config file: $config_file"
        
    - name: Validate Single Recipe Inputs
      if: steps.mode.outputs.mode == 'single'
      shell: bash
      run: |
        # For single recipe execution, recipe_name comes from matrix.recipe_name
        if [[ -z "${{ matrix.recipe_name }}" ]]; then
          echo "âŒ matrix.recipe_name is required for single recipe execution"
          exit 1
        fi
        
        if [[ -z "${{ matrix.recipe_type }}" ]]; then
          echo "âŒ matrix.recipe_type is required for single recipe execution"
          exit 1
        fi
        
        # Validate recipe type
        if [[ "${{ matrix.recipe_type }}" != "esmvaltool" && "${{ matrix.recipe_type }}" != "cosima" ]]; then
          echo "âŒ Invalid recipe_type: ${{ matrix.recipe_type }}. Must be 'esmvaltool' or 'cosima'"
          exit 1
        fi
        
        echo "âœ… Single recipe validation passed"
        echo "Recipe type: ${{ matrix.recipe_type }}"
        echo "Recipe name: ${{ matrix.recipe_name }}"
        
    - name: Generate Recipe Matrix
      id: list-recipes
      if: steps.mode.outputs.mode == 'matrix'
      shell: bash
      run: |
        echo "ğŸ“‹ Generating recipe matrix from configuration file"
        echo "ğŸ“„ Using configuration file: ${{ inputs.config_file }}"
        
        # Run the recipe matrix generator with config file
        python "${{ github.action_path }}/lib/recipe_matrix_generator.py" \
          --config "${{ inputs.config_file }}" \
          --output matrix > recipe_matrix.json
        
        # Also output the count for information
        recipe_count=$(python "${{ github.action_path }}/lib/recipe_matrix_generator.py" \
          --config "${{ inputs.config_file }}" \
          --output count)
        
        echo "Generated matrix:"
        cat recipe_matrix.json
        
        # Set output for GitHub Actions matrix
        echo "matrix=$(cat recipe_matrix.json)" >> $GITHUB_OUTPUT
        echo "recipe_count=$recipe_count" >> $GITHUB_OUTPUT
        echo "status=matrix-generated" >> $GITHUB_OUTPUT
        echo "âœ… Found $recipe_count recipe(s) to execute"
        
    - name: Generate PBS Script
      id: generate-pbs
      if: steps.mode.outputs.mode == 'single'
      shell: bash
      run: |
        echo "ğŸ¯ Generating PBS script for ${{ matrix.recipe_type }} recipe: ${{ matrix.recipe_name }}"
        
        # Create simple PBS generation script
        cat > generate_pbs.py << 'EOF'
        import sys
        import os
        import json
        import ast
        from pathlib import Path
        
        # Add lib directory to path
        sys.path.insert(0, os.path.join(os.environ.get('GITHUB_ACTION_PATH', '.'), 'lib'))
        
        def safe_parse_config(config_str):
            """Safely parse configuration string, trying multiple formats."""
            if not config_str or config_str == '{}':
                return {}
            
            # Try JSON first
            try:
                return json.loads(config_str)
            except json.JSONDecodeError:
                pass
            
            # Try to parse as Python literal first
            try:
                return ast.literal_eval(config_str)
            except (ValueError, SyntaxError):
                pass
            
            # Try to fix the specific format: {key: value, key: value}
            # by adding quotes around keys and string values
            try:
                # Remove outer braces temporarily
                if config_str.startswith('{') and config_str.endswith('}'):
                    content = config_str[1:-1].strip()
                    
                    # Split by commas but be careful of commas in values
                    pairs = []
                    current_pair = ""
                    brace_count = 0
                    
                    for char in content + ',':  # Add comma at end to process last pair
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                        elif char == ',' and brace_count == 0:
                            if current_pair.strip():
                                pairs.append(current_pair.strip())
                            current_pair = ""
                            continue
                        current_pair += char
                    
                    # Process each key-value pair
                    fixed_pairs = []
                    for pair in pairs:
                        if ':' in pair:
                            key, value = pair.split(':', 1)
                            key = key.strip()
                            value = value.strip()
                            
                            # Add quotes around key if not already quoted
                            if not (key.startswith('"') and key.endswith('"')):
                                key = f'"{key}"'
                            
                            # Add quotes around value if it's not a number and not already quoted
                            if not (value.startswith('"') and value.endswith('"')):
                                # Check if it's a number
                                try:
                                    float(value)
                                    # It's a number, keep as is
                                except ValueError:
                                    # It's a string, add quotes
                                    value = f'"{value}"'
                            
                            fixed_pairs.append(f'{key}: {value}')
                    
                    fixed_config = '{' + ', '.join(fixed_pairs) + '}'
                    return json.loads(fixed_config)
                    
            except Exception:
                pass
            
            print(f"Warning: Could not parse config '{config_str}', using empty config")
            return {}
        
        try:
            from recipe_runner import SmartRecipeRunner
            
            # Create runner
            runner = SmartRecipeRunner()
            
            # Get parameters
            recipe_name = sys.argv[1]
            config_str = sys.argv[2] if len(sys.argv) > 2 else '{}'
            recipe_type = sys.argv[3] if len(sys.argv) > 3 else 'esmvaltool'
            esmvaltool_version = sys.argv[4] if len(sys.argv) > 4 else 'main'
            conda_module = sys.argv[5] if len(sys.argv) > 5 else 'conda/analysis3'
            project = sys.argv[6] if len(sys.argv) > 6 else 'w40'
            repository_url = sys.argv[7] if len(sys.argv) > 7 and sys.argv[7] != 'None' else None
            
            # Parse configuration safely
            config_dict = safe_parse_config(config_str)
            config_json = json.dumps(config_dict)
            
            print(f"Parameters:")
            print(f"  Recipe: {recipe_name}")
            print(f"  Type: {recipe_type}")
            print(f"  Config: {config_json}")
            print(f"  ESMValTool version: {esmvaltool_version}")
            print(f"  Conda module: {conda_module}")
            print(f"  Project: {project}")
            print(f"  Repository URL: {repository_url}")
            
            # Generate PBS script
            result = runner.run(
                recipe_name=recipe_name,
                config_json=config_json,
                recipe_type=recipe_type,
                esmvaltool_version=esmvaltool_version,
                conda_module=conda_module,
                project=project,
                repository_url=repository_url
            )
            
            print(f"âœ… PBS generation completed: {result}")
            
            # Write outputs for GitHub Actions
            with open('pbs_result.txt', 'w') as f:
                f.write(f"status={result[0]}\n")
                f.write(f"pbs_filename={result[1]}\n")
                
        except Exception as e:
            print(f"âŒ Error generating PBS script: {e}")
            import traceback
            traceback.print_exc()
            
            with open('pbs_result.txt', 'w') as f:
                f.write("status=error\n")
                f.write("pbs_filename=\n")
            sys.exit(1)
        EOF
        
        # Run PBS generation
        python generate_pbs.py \
          "${{ matrix.recipe_name }}" \
          "${{ matrix.recipe_config }}" \
          "${{ matrix.recipe_type }}" \
          "${{ inputs.esmvaltool_version }}" \
          "${{ inputs.conda_module }}" \
          "${{ inputs.project }}" \
          "${{ inputs.repository_url }}"
        
        # Set outputs
        if [[ -f "pbs_result.txt" ]]; then
          while IFS= read -r line; do
            echo "$line" >> $GITHUB_OUTPUT
          done < pbs_result.txt
        else
          echo "status=error" >> $GITHUB_OUTPUT
          echo "pbs_filename=" >> $GITHUB_OUTPUT
        fi
        
    - name: Display Results
      if: steps.mode.outputs.mode == 'single'
      shell: bash
      run: |
        echo "ğŸ“‹ PBS Script Generation Results:"
        echo "Status: ${{ steps.generate-pbs.outputs.status }}"
        echo "PBS Filename: ${{ steps.generate-pbs.outputs.pbs_filename }}"
        
        if [[ "${{ steps.generate-pbs.outputs.status }}" == "pbs-generated" ]]; then
          echo ""
          echo "âœ… PBS script generated successfully!"
          echo "ğŸ“ Script saved as: ${{ steps.generate-pbs.outputs.pbs_filename }}"
          
          if [[ -f "${{ steps.generate-pbs.outputs.pbs_filename }}" ]]; then
            echo ""
            echo "--- PBS Script Content Preview ---"
            head -20 "${{ steps.generate-pbs.outputs.pbs_filename }}"
            echo "..."
            echo "--- End Preview ---"
          fi
        else
          echo "âŒ PBS script generation failed"
          exit 1
        fi

    - name: Read PBS Content for Upload
      id: read-pbs
      if: steps.mode.outputs.mode == 'single'
      shell: bash
      run: |
        if [[ -f "${{ steps.generate-pbs.outputs.pbs_filename }}" ]]; then
          echo "ğŸ“„ Reading PBS content for upload to Gadi..."
          # Create a base64 encoded version for safe transfer
          PBS_B64=$(base64 -w 0 "${{ steps.generate-pbs.outputs.pbs_filename }}")
          echo "pbs_content_b64=$PBS_B64" >> $GITHUB_OUTPUT
          echo "âœ… PBS content prepared for upload"
        else
          echo "âŒ PBS file not found: ${{ steps.generate-pbs.outputs.pbs_filename }}"
          exit 1
        fi

    - name: Clone Repository and Submit Job to Gadi
      id: submit-job
      if: steps.mode.outputs.mode == 'single' && inputs.submit_job == 'true' && inputs.gadi_username != '' && inputs.gadi_ssh_key != ''
      uses: appleboy/ssh-action@v1
      with:
        host: 'gadi.nci.org.au'
        username: ${{ inputs.gadi_username }}
        key: ${{ inputs.gadi_ssh_key }}
        passphrase: ${{ inputs.gadi_ssh_passphrase }}
        script: |
          set -e
          
          echo "ğŸš€ Preparing repository and submitting job to Gadi..."
          
          PBS_FILENAME="${{ steps.generate-pbs.outputs.pbs_filename }}"
          SCRIPTS_DIR="${{ inputs.scripts_dir }}"
          RECIPE_NAME="${{ matrix.recipe_name }}"
          RECIPE_TYPE="${{ matrix.recipe_type }}"
          REPOSITORY_URL="${{ inputs.repository_url }}"
          
          # Decode the PBS content
          echo "${{ steps.read-pbs.outputs.pbs_content_b64 }}" | base64 -d > /tmp/pbs_content.pbs
          
          echo "ğŸ“ Creating scripts directory: $SCRIPTS_DIR"
          mkdir -p "$SCRIPTS_DIR"
          
          # Clone/update repository before submitting job
          echo "ğŸ“¦ Setting up repository on Gadi login node (with internet access)..."
          cd "$SCRIPTS_DIR/../"
          
          if [[ "$RECIPE_TYPE" == "cosima" ]]; then
            REPO_URL="${REPOSITORY_URL:-https://github.com/COSIMA/cosima-recipes}"
            REPO_DIR="COSIMA-recipes-ci"
            echo "ğŸ”„ Setting up COSIMA repository: $REPO_URL"
          else
            REPO_URL="${REPOSITORY_URL:-https://github.com/ESMValGroup/ESMValTool}"
            REPO_DIR="ESMValTool-ci"
            echo "ğŸ”„ Setting up ESMValTool repository: $REPO_URL"
          fi
          
          if [ ! -d "$REPO_DIR" ]; then
            echo "ğŸ“¦ Cloning repository: $REPO_URL"
            git clone "$REPO_URL" "$REPO_DIR"
            if [ $? -eq 0 ]; then
              echo "âœ… Repository cloned successfully"
            else
              echo "âŒ Failed to clone repository"
              exit 1
            fi
          else
            echo "ğŸ”„ Repository exists, updating..."
            cd "$REPO_DIR"
            git fetch origin
            git pull origin main
            if [ $? -eq 0 ]; then
              echo "âœ… Repository updated successfully"
            else
              echo "âš ï¸  Warning: Failed to update repository, continuing with existing version"
            fi
            cd ..
          fi
          
          echo "ğŸ“‚ Repository setup complete: $(pwd)/$REPO_DIR"
          
          echo "ğŸ“¤ Creating PBS script on Gadi: $SCRIPTS_DIR/$PBS_FILENAME"
          cp /tmp/pbs_content.pbs "$SCRIPTS_DIR/$PBS_FILENAME"
          chmod +x "$SCRIPTS_DIR/$PBS_FILENAME"
          
          echo "ğŸ“‹ Submitting job with qsub..."
          cd "$SCRIPTS_DIR"
          JOB_OUTPUT=$(qsub "$PBS_FILENAME")
          
          # Extract job ID from qsub output
          JOB_ID=$(echo "$JOB_OUTPUT" | grep -oE '[0-9]+\.[a-zA-Z0-9]+' | head -1)
          
          echo "âœ… Job submitted successfully!"
          echo "Job ID: $JOB_ID"
          echo "PBS file: $SCRIPTS_DIR/$PBS_FILENAME"
          echo "Recipe: $RECIPE_NAME"
          echo "Repository: $(pwd)/../$REPO_DIR"
          
          # Write a simple status file for reference
          echo "job_id=$JOB_ID" > "$SCRIPTS_DIR/.job_status_$RECIPE_NAME.txt"
          echo "gadi_path=$SCRIPTS_DIR/$PBS_FILENAME" >> "$SCRIPTS_DIR/.job_status_$RECIPE_NAME.txt"
          echo "repository_path=$(pwd)/../$REPO_DIR" >> "$SCRIPTS_DIR/.job_status_$RECIPE_NAME.txt"
          echo "status=job-submitted" >> "$SCRIPTS_DIR/.job_status_$RECIPE_NAME.txt"
          echo "submission_time=$(date)" >> "$SCRIPTS_DIR/.job_status_$RECIPE_NAME.txt"
          
          echo "ğŸ“‹ Job submission completed"
          echo "Monitor with: qstat $JOB_ID"

    - name: Set Job Outputs
      id: set-job-outputs
      if: steps.mode.outputs.mode == 'single' && inputs.submit_job == 'true' && inputs.gadi_username != '' && inputs.gadi_ssh_key != ''
      shell: bash
      run: |
        # Since we can't easily get outputs from SSH action, we'll construct them
        # from the information we have. The actual job ID will be shown in the SSH action output.
        GADI_PATH="${{ inputs.scripts_dir }}/${{ steps.generate-pbs.outputs.pbs_filename }}"
        
        echo "job_id=check-ssh-output" >> $GITHUB_OUTPUT
        echo "gadi_path=$GADI_PATH" >> $GITHUB_OUTPUT
        echo "status=job-submitted" >> $GITHUB_OUTPUT
        
        echo "ğŸ“‹ Job information:"
        echo "Status: job-submitted"
        echo "Gadi Path: $GADI_PATH"
        echo "Note: Check the SSH action output above for the actual Job ID"

    - name: Display Final Results
      if: steps.mode.outputs.mode == 'single'
      shell: bash
      run: |
        echo "ğŸ¯ Smart Recipe Runner - Final Results"
        echo "=================================="
        
        if [[ "${{ inputs.submit_job }}" == "true" ]]; then
          if [[ -n "${{ inputs.gadi_username }}" && -n "${{ inputs.gadi_ssh_key }}" ]]; then
            echo "ğŸ“‹ Job Submission Results:"
            echo "Status: ${{ steps.set-job-outputs.outputs.status || 'job-submitted' }}"
            echo "Gadi Path: ${{ steps.set-job-outputs.outputs.gadi_path }}"
            echo ""
            echo "âœ… Job has been submitted to Gadi HPC!"
            echo "ğŸ” Check the SSH action output above for the Job ID"
            echo "ğŸ” Monitor job status with: qstat [JOB_ID]"
          else
            echo "âš ï¸  submit_job=true but missing gadi_username or gadi_ssh_key"
            echo "ğŸ“‹ PBS script generated but not submitted"
            echo "PBS file: ${{ steps.generate-pbs.outputs.pbs_filename }}"
          fi
        else
          echo "ğŸ“‹ PBS Script Generation Mode:"
          echo "Status: ${{ steps.generate-pbs.outputs.status }}"
          echo "PBS file: ${{ steps.generate-pbs.outputs.pbs_filename }}"
          echo ""
          echo "ğŸ’¡ To submit to Gadi, set submit_job=true and provide SSH credentials"
        fi
        
branding:
  icon: 'play-circle'
  color: 'blue'
